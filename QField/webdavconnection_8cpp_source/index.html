
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      
      
        
      
      
      <link rel="icon" href="../../assets/images/favicon.ico">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.7.1">
    
    
      
        <title>File webdavconnection.cpp - QField API Documentation</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.484c7ddc.min.css">
      
        
        <link rel="stylesheet" href="../../assets/stylesheets/palette.ab4e12ef.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="light-green" data-md-color-accent="indigo">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#file-webdavconnectioncpp" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../.." title="QField API Documentation" class="md-header__button md-logo" aria-label="QField API Documentation" data-md-component="logo">
      
  <img src="../../assets/images/qfield_logo_white.svg" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            QField API Documentation
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              File webdavconnection.cpp
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="default" data-md-color-primary="light-green" data-md-color-accent="indigo"  aria-label="Switch to dark mode"  type="radio" name="__palette" id="__palette_0">
    
      <label class="md-header__button md-icon" title="Switch to dark mode" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M14.768 3.96zl-.002-.005a9 9 0 0 0-.218-.779c-.13-.394.21-.8.602-.67q.435.144.855.328l.01.005A10.002 10.002 0 0 1 12 22a10 10 0 0 1-9.162-5.985l-.004-.01a10 10 0 0 1-.329-.855c-.13-.392.277-.732.67-.602q.386.126.78.218l.004.002A9 9 0 0 0 14.999 6a9 9 0 0 0-.231-2.04M16.5 6c0 5.799-4.701 10.5-10.5 10.5q-.64 0-1.26-.075A8.5 8.5 0 1 0 16.425 4.74q.075.62.075 1.259Z"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="slate" data-md-color-primary="blue" data-md-color-accent="indigo"  aria-label="Switch to light mode"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="Switch to light mode" for="__palette_0" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 19a7 7 0 1 1 0-14 7 7 0 0 1 0 14m0-1.5a5.5 5.5 0 1 0 0-11 5.5 5.5 0 1 0 0 11m-5.657.157a.75.75 0 0 1 0 1.06l-1.768 1.768a.749.749 0 0 1-1.275-.326.75.75 0 0 1 .215-.734l1.767-1.768a.75.75 0 0 1 1.061 0M3.515 3.515a.75.75 0 0 1 1.06 0l1.768 1.768a.749.749 0 0 1-.326 1.275.75.75 0 0 1-.734-.215L3.515 4.575a.75.75 0 0 1 0-1.06M12 0a.75.75 0 0 1 .75.75v2.5a.75.75 0 0 1-1.5 0V.75A.75.75 0 0 1 12 0M4 12a.75.75 0 0 1-.75.75H.75a.75.75 0 0 1 0-1.5h2.5A.75.75 0 0 1 4 12m8 8a.75.75 0 0 1 .75.75v2.5a.75.75 0 0 1-1.5 0v-2.5A.75.75 0 0 1 12 20m12-8a.75.75 0 0 1-.75.75h-2.5a.75.75 0 0 1 0-1.5h2.5A.75.75 0 0 1 24 12m-6.343 5.657a.75.75 0 0 1 1.06 0l1.768 1.768a.75.75 0 0 1-.018 1.042.75.75 0 0 1-1.042.018l-1.768-1.767a.75.75 0 0 1 0-1.061m2.828-14.142a.75.75 0 0 1 0 1.06l-1.768 1.768a.75.75 0 0 1-1.042-.018.75.75 0 0 1-.018-1.042l1.767-1.768a.75.75 0 0 1 1.061 0"/></svg>
      </label>
    
  
</form>
      
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="QField API Documentation" class="md-nav__button md-logo" aria-label="QField API Documentation" data-md-component="logo">
      
  <img src="../../assets/images/qfield_logo_white.svg" alt="logo">

    </a>
    QField API Documentation
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Home
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../snippets/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    Code Snippets
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../group__core/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    C++ Classes
  

    
  </span>
  
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../group__qml/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    
  
    QML Items
  

    
  </span>
  
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              
              <article class="md-content__inner md-typeset">
                
                  



<h1 id="file-webdavconnectioncpp">File webdavconnection.cpp</h1>
<p><a href="../files/"><strong>File List</strong></a> <strong>&gt;</strong> <a href="../dir_aebb8dcc11953d78e620bbef0b9e2183/"><strong>core</strong></a> <strong>&gt;</strong> <a href="../webdavconnection_8cpp/"><strong>webdavconnection.cpp</strong></a></p>
<p><a href="../webdavconnection_8cpp/">Go to the documentation of this file</a></p>
<pre><code class="language-C++">/***************************************************************************
                          webdavconnection.cpp
                             -------------------
  begin                : January 2025
  copyright            : (C) 2025 by Mathieu Pellerin
  email                : mathieu@opengis.ch
***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/


#include &quot;platformutilities.h&quot;
#include &quot;webdavconnection.h&quot;

#include &lt;QDirIterator&gt;
#include &lt;QSettings&gt;
#include &lt;QtWebDAV/qwebdavitem.h&gt;
#include &lt;qgsapplication.h&gt;
#include &lt;qgsauthmanager.h&gt;

WebdavConnection::WebdavConnection( QObject *parent )
  : QObject( parent )
{
  connect( &amp;mWebdavConnection, &amp;QWebdav::errorChanged, this, &amp;WebdavConnection::processConnectionError );
  connect( &amp;mWebdavDirParser, &amp;QWebdavDirParser::errorChanged, this, &amp;WebdavConnection::processDirParserError );
  connect( &amp;mWebdavDirParser, &amp;QWebdavDirParser::finished, this, &amp;WebdavConnection::processDirParserFinished );
}

void WebdavConnection::setUrl( const QString &amp;url )
{
  if ( mUrl == url.trimmed() )
    return;

  mUrl = url.trimmed();
  emit urlChanged();

  if ( !mAvailablePaths.isEmpty() )
  {
    mAvailablePaths.clear();
    emit availablePathsChanged();
  }

  checkStoredPassword();
}

void WebdavConnection::setUsername( const QString &amp;username )
{
  if ( mUsername == username )
    return;

  mUsername = username;
  emit usernameChanged();

  if ( !mAvailablePaths.isEmpty() )
  {
    mAvailablePaths.clear();
    emit availablePathsChanged();
  }

  mWebdavConnection.clearAccessCache();
  checkStoredPassword();
}

void WebdavConnection::setPassword( const QString &amp;password )
{
  if ( mPassword == password )
    return;

  mPassword = password;
  emit passwordChanged();

  if ( !mAvailablePaths.isEmpty() )
  {
    mAvailablePaths.clear();
    emit availablePathsChanged();
  }

  mWebdavConnection.clearAccessCache();
}

void WebdavConnection::setStorePassword( bool storePassword )
{
  if ( mStorePassword == storePassword )
    return;

  mStorePassword = storePassword;
  emit storePasswordChanged();
}

void WebdavConnection::checkStoredPassword()
{
  mStoredPassword.clear();

  if ( !mUrl.isEmpty() &amp;&amp; !mUsername.isEmpty() )
  {
    QgsAuthManager *authManager = QgsApplication::authManager();
    QgsAuthMethodConfigsMap configs = authManager-&gt;availableAuthMethodConfigs();
    for ( QgsAuthMethodConfig &amp;config : configs )
    {
      if ( config.uri() == mUrl )
      {
        authManager-&gt;loadAuthenticationConfig( config.id(), config, true );
        if ( config.config( QStringLiteral( &quot;username&quot; ) ) == mUsername )
        {
          mStoredPassword = config.config( QStringLiteral( &quot;password&quot; ) );
        }
      }
    }
  }

  emit isPasswordStoredChanged();
}

void WebdavConnection::applyStoredPassword()
{
  QgsAuthManager *authManager = QgsApplication::authManager();
  QgsAuthMethodConfigsMap configs = authManager-&gt;availableAuthMethodConfigs();
  if ( mStorePassword )
  {
    if ( !mPassword.isEmpty() )
    {
      bool found = false;
      for ( QgsAuthMethodConfig &amp;config : configs )
      {
        if ( config.uri() == mUrl )
        {
          authManager-&gt;loadAuthenticationConfig( config.id(), config, true );
          if ( config.config( QStringLiteral( &quot;username&quot; ) ) == mUsername )
          {
            if ( config.config( QStringLiteral( &quot;password&quot; ) ) != mPassword )
            {
              config.setConfig( &quot;password&quot;, mPassword );
              authManager-&gt;updateAuthenticationConfig( config );

              mStoredPassword = mPassword;
              emit isPasswordStoredChanged();
            }

            found = true;
            break;
          }
        }
      }

      if ( !found )
      {
        QgsAuthMethodConfig config( QStringLiteral( &quot;Basic&quot; ) );
        config.setName( QStringLiteral( &quot;WebDAV created on %1&quot; ).arg( QDateTime::currentDateTime().toString() ) );
        config.setUri( mUrl );
        config.setConfig( &quot;username&quot;, mUsername );
        config.setConfig( &quot;password&quot;, mPassword );
        authManager-&gt;storeAuthenticationConfig( config );

        mStoredPassword = mPassword;
        emit isPasswordStoredChanged();
      }
    }
  }
  else
  {
    for ( QgsAuthMethodConfig &amp;config : configs )
    {
      if ( config.uri() == mUrl )
      {
        authManager-&gt;loadAuthenticationConfig( config.id(), config, true );
        if ( config.config( QStringLiteral( &quot;username&quot; ) ) == mUsername )
        {
          authManager-&gt;removeAuthenticationConfig( config.id() );
        }
      }
    }

    if ( !mStoredPassword.isEmpty() )
    {
      mStoredPassword.clear();
      emit isPasswordStoredChanged();
    }
  }
}

void WebdavConnection::setupConnection()
{
  QUrl connectionUrl( mUrl );
  bool isHttps = connectionUrl.scheme() == QStringLiteral( &quot;https&quot; );
  mWebdavConnection.setConnectionSettings( isHttps ? QWebdav::HTTPS : QWebdav::HTTP, connectionUrl.host(), connectionUrl.path( QUrl::FullyEncoded ), mUsername, !mPassword.isEmpty() ? mPassword : mStoredPassword );
}

void WebdavConnection::fetchAvailablePaths()
{
  if ( mUrl.isEmpty() || mUsername.isEmpty() || ( mPassword.isEmpty() &amp;&amp; mStoredPassword.isEmpty() ) )
    return;

  mAvailablePaths.clear();
  emit availablePathsChanged();

  setupConnection();

  mIsFetchingAvailablePaths = true;
  emit isFetchingAvailablePathsChanged();

  mWebdavDirParser.listDirectory( &amp;mWebdavConnection, QStringLiteral( &quot;/&quot; ), true );
}

void WebdavConnection::processDirParserFinished()
{
  const QList&lt;QWebdavItem&gt; list = mWebdavDirParser.getList();
  if ( mIsFetchingAvailablePaths )
  {
    if ( !list.isEmpty() )
    {
      applyStoredPassword();

      mAvailablePaths &lt;&lt; QStringLiteral( &quot;/&quot; );
      for ( const QWebdavItem &amp;item : list )
      {
        if ( item.isDir() )
        {
          mAvailablePaths &lt;&lt; item.path();
        }
      }
    }
    mAvailablePaths.sort();

    mIsFetchingAvailablePaths = false;
    emit isFetchingAvailablePathsChanged();
    emit availablePathsChanged();
  }
  else if ( mIsImportingPath || mIsDownloadingPath )
  {
    if ( !list.isEmpty() )
    {
      applyStoredPassword();

      QDir localDir( mProcessLocalPath );
      for ( const QWebdavItem &amp;item : list )
      {
        if ( item.isDir() )
        {
          localDir.mkpath( item.path().mid( mProcessRemotePath.size() ) );
        }
        else
        {
          if ( mIsDownloadingPath )
          {
            QFileInfo fileInfo( mProcessLocalPath + item.path().mid( mProcessRemotePath.size() ) );
            if ( !fileInfo.exists() || ( fileInfo.fileTime( QFileDevice::FileModificationTime ) != item.lastModified() ) )
            {
              mWebdavItems &lt;&lt; item;
              mBytesTotal += item.size();
            }
          }
          else
          {
            mWebdavItems &lt;&lt; item;
            mBytesTotal += item.size();
          }
        }
      }
      emit progressChanged();
    }

    getWebdavItems();
  }
  else if ( mIsUploadingPath )
  {
    if ( !mWebdavLastModified.isEmpty() )
    {
      // Adjust modified date to match upload files
      for ( const QWebdavItem &amp;item : list )
      {
        if ( mWebdavLastModified.contains( item.path() ) )
        {
          QFile file( mProcessLocalPath + item.path().mid( mProcessRemotePath.size() ) );
          if ( file.exists() )
          {
            // The local file should always exist at this stage, just playing safe
            file.open( QFile::Append );
            file.setFileTime( item.lastModified(), QFileDevice::FileModificationTime );
            file.setFileTime( item.lastModified(), QFileDevice::FileAccessTime );
            file.close();
          }
        }
      }
      mWebdavLastModified.clear();

      mIsUploadingPath = false;
      emit isUploadingPathChanged();
    }
    else
    {
      // Filter files to  upload
      applyStoredPassword();

      QStringList remoteDirs;
      for ( const QWebdavItem &amp;item : list )
      {
        if ( item.isDir() )
        {
          remoteDirs &lt;&lt; item.path();
        }
        else
        {
          QFileInfo fileInfo( mProcessLocalPath + item.path().mid( mProcessRemotePath.size() ) );
          if ( fileInfo.exists() )
          {
            auto localFileInfo = std::find_if( mLocalItems.begin(), mLocalItems.end(), [&amp;fileInfo]( const QFileInfo &amp;entry ) {
              return entry.absoluteFilePath() == fileInfo.absoluteFilePath();
            } );

            if ( localFileInfo != mLocalItems.end() )
            {
              if ( localFileInfo-&gt;fileTime( QFileDevice::FileModificationTime ) == item.lastModified() )
              {
                mLocalItems.remove( localFileInfo - mLocalItems.begin(), 1 );
              }
            }
          }
        }
      }

      mWebdavMkDirs.clear();

      if ( !remoteDirs.contains( mProcessRemotePath ) )
      {
        mWebdavMkDirs &lt;&lt; mProcessRemotePath;
      }

      for ( const QFileInfo &amp;fileInfo : mLocalItems )
      {
        // Insure the path exists remotely
        QString remoteDir = mProcessRemotePath + fileInfo.absolutePath().mid( mProcessLocalPath.size() ).replace( QDir::separator(), &quot;/&quot; );
        if ( !remoteDirs.contains( remoteDir ) &amp;&amp; !mWebdavMkDirs.contains( remoteDir ) )
        {
          const QStringList remoteDirParts = remoteDir.mid( mProcessRemotePath.size() ).split( &quot;/&quot;, Qt::SkipEmptyParts );
          remoteDir = mProcessRemotePath;
          for ( const QString &amp;part : remoteDirParts )
          {
            remoteDir += part + &quot;/&quot;;
            if ( !remoteDirs.contains( remoteDir ) &amp;&amp; !mWebdavMkDirs.contains( remoteDir ) )
            {
              mWebdavMkDirs &lt;&lt; remoteDir;
            }
          }
        }

        mBytesTotal += fileInfo.size();
      }
      emit progressChanged();

      putLocalItems();
    }
  }
}

void WebdavConnection::getWebdavItems()
{
  if ( !mWebdavItems.isEmpty() )
  {
    const QString itemPath = mWebdavItems.first().path();
    const QDateTime itemLastModified = mWebdavItems.first().lastModified();
    QNetworkReply *reply = mWebdavConnection.get( itemPath );
    QTemporaryFile *temporaryFile = new QTemporaryFile( reply );
    temporaryFile-&gt;setFileTemplate( QStringLiteral( &quot;%1%2.XXXXXXXXXXXX&quot; ).arg( mProcessLocalPath, itemPath.mid( mProcessRemotePath.size() ) ) );
    temporaryFile-&gt;open();

    connect( reply, &amp;QNetworkReply::downloadProgress, this, [this, reply, temporaryFile]( qint64 bytesReceived, qint64 bytesTotal ) {
      mCurrentBytesProcessed = bytesReceived;
      emit progressChanged();

      temporaryFile-&gt;write( reply-&gt;readAll() );
    } );

    connect( reply, &amp;QNetworkReply::finished, this, [this, reply, temporaryFile, itemPath, itemLastModified]() {
      mBytesProcessed += mCurrentBytesProcessed;
      mCurrentBytesProcessed = 0;
      if ( reply-&gt;error() == QNetworkReply::NoError )
      {
        QFile file( mProcessLocalPath + itemPath.mid( mProcessRemotePath.size() ) );
        if ( file.exists() )
        {
          // Remove pre-existing file
          file.remove();
        }

        temporaryFile-&gt;write( reply-&gt;readAll() );
        temporaryFile-&gt;setAutoRemove( false );
        temporaryFile-&gt;rename( mProcessLocalPath + itemPath.mid( mProcessRemotePath.size() ) );
        temporaryFile-&gt;close();
        delete temporaryFile;

        // Attach last modified date value coming from the server (cannot be done via QTemporaryFile)
        file.open( QFile::Append );
        file.setFileTime( itemLastModified, QFileDevice::FileModificationTime );
        file.setFileTime( itemLastModified, QFileDevice::FileAccessTime );
        file.close();
      }
      else
      {
        mLastError = tr( &quot;Failed to download file %1 due to network error (%2)&quot; ).arg( itemPath ).arg( reply-&gt;error() );
      }

      mWebdavItems.removeFirst();
      getWebdavItems();
      reply-&gt;deleteLater();
    } );
  }
  else
  {
    if ( mIsImportingPath )
    {
      QVariantMap webdavConfiguration;
      webdavConfiguration[QStringLiteral( &quot;url&quot; )] = mUrl;
      webdavConfiguration[QStringLiteral( &quot;username&quot; )] = mUsername;
      webdavConfiguration[QStringLiteral( &quot;remote_path&quot; )] = mProcessRemotePath;

      QJsonDocument jsonDocument = QJsonDocument::fromVariant( webdavConfiguration );
      QFile jsonFile( QStringLiteral( &quot;%1qfield_webdav_configuration.json&quot; ).arg( mProcessLocalPath ) );
      jsonFile.open( QFile::WriteOnly );
      jsonFile.write( jsonDocument.toJson() );
      jsonFile.close();

      QSettings settings;
      settings.beginGroup( QStringLiteral( &quot;/qfield/webdavImports/%1/users/%2&quot; ).arg( QUrl::toPercentEncoding( mUrl ), QUrl::toPercentEncoding( mUsername ) ) );
      settings.setValue( QStringLiteral( &quot;lastImportPath&quot; ), mProcessRemotePath );
      settings.setValue( QStringLiteral( &quot;lastImportTime&quot; ), QDateTime::currentDateTime() );
      settings.endGroup();

      mIsImportingPath = false;
      emit isImportingPathChanged();
      emit importSuccessful( mProcessLocalPath );
    }
    else if ( mIsDownloadingPath )
    {
      mIsDownloadingPath = false;
      emit isDownloadingPathChanged();
    }
  }
}

void WebdavConnection::forgetHistory( const QString &amp;url, const QString &amp;username )
{
  QgsAuthManager *authManager = QgsApplication::authManager();
  QgsAuthMethodConfigsMap configs = authManager-&gt;availableAuthMethodConfigs();
  QSettings settings;
  if ( !username.isEmpty() )
  {
    // Add a dummy value into the root of the server to avoid it being deleted due to empty group
    settings.setValue( QStringLiteral( &quot;/qfield/webdavImports/%1/dummy&quot; ).arg( QUrl::toPercentEncoding( url ) ), 1 );
    settings.beginGroup( QStringLiteral( &quot;/qfield/webdavImports/%1/users/%2&quot; ).arg( QUrl::toPercentEncoding( url ), QUrl::toPercentEncoding( username ) ) );
    settings.remove( &quot;&quot; );
    settings.endGroup();

    for ( QgsAuthMethodConfig &amp;config : configs )
    {
      if ( config.uri() == url )
      {
        authManager-&gt;loadAuthenticationConfig( config.id(), config, true );
        if ( config.config( QStringLiteral( &quot;username&quot; ) ) == username )
        {
          authManager-&gt;removeAuthenticationConfig( config.id() );
        }
      }
    }
  }
  else if ( !url.isEmpty() )
  {
    settings.beginGroup( QStringLiteral( &quot;/qfield/webdavImports/%1&quot; ).arg( QUrl::toPercentEncoding( url ) ) );
    settings.remove( &quot;&quot; );
    settings.endGroup();

    for ( QgsAuthMethodConfig &amp;config : configs )
    {
      if ( config.uri() == url )
      {
        authManager-&gt;removeAuthenticationConfig( config.id() );
      }
    }
  }
  else
  {
    settings.beginGroup( QStringLiteral( &quot;/qfield/webdavImports&quot; ) );
    const QStringList urls = settings.allKeys();
    settings.remove( &quot;&quot; );
    settings.endGroup();

    for ( QgsAuthMethodConfig &amp;config : configs )
    {
      if ( urls.contains( config.uri() ) )
      {
        authManager-&gt;removeAuthenticationConfig( config.id() );
      }
    }
  }
}

QVariantMap WebdavConnection::importHistory()
{
  // Collect imported folders
  QMap&lt;QString, QVariantMap&gt; importedFolders;
  QDir importedProjectsDir( QStringLiteral( &quot;%1/Imported Projects/&quot; ).arg( PlatformUtilities::instance()-&gt;applicationDirectory() ), { QStringLiteral( &quot;qfield_webdav_configuration.json&quot; ) } );
  QDirIterator it( importedProjectsDir.absolutePath(), QDir::Filter::Files, QDirIterator::Subdirectories );
  while ( it.hasNext() )
  {
    QFile webdavConfigurationFile( it.next() );
    webdavConfigurationFile.open( QFile::ReadOnly );
    QJsonDocument jsonDocument = QJsonDocument::fromJson( webdavConfigurationFile.readAll() );
    if ( !jsonDocument.isEmpty() )
    {
      QVariantMap webdavConfiguration = jsonDocument.toVariant().toMap();
      const QString importedFolderKey = QStringLiteral( &quot;%1 - %2&quot; ).arg( webdavConfiguration[&quot;url&quot;].toString(), webdavConfiguration[&quot;username&quot;].toString() );
      importedFolders[importedFolderKey][webdavConfiguration[&quot;remote_path&quot;].toString()] = importedProjectsDir.relativeFilePath( it.fileInfo().path() );
    }
  }

  // Collect saved imports
  QVariantMap history;

  QSettings settings;
  settings.beginGroup( QStringLiteral( &quot;/qfield/webdavImports&quot; ) );
  const QStringList urls = settings.childGroups();
  settings.endGroup();

  QDateTime lastUrlImportTime( QDate( 1900, 0, 0 ), QTime( 0, 0, 0, 0 ) );
  QString lastUrl;
  QVariantMap urlsDetails;
  for ( const QString &amp;url : urls )
  {
    const QString decodedUrl = QUrl::fromPercentEncoding( url.toLatin1() );
    settings.beginGroup( QStringLiteral( &quot;/qfield/webdavImports/%1/users&quot; ).arg( url ) );
    const QStringList users = settings.childGroups();
    settings.endGroup();

    QDateTime lastUserImportTime( QDate( 1900, 0, 0 ), QTime( 0, 0, 0, 0 ) );
    QString lastUser;
    QVariantMap usersDetails;
    for ( const QString &amp;user : users )
    {
      const QString decodedUser = QUrl::fromPercentEncoding( user.toLatin1() );
      settings.beginGroup( QStringLiteral( &quot;/qfield/webdavImports/%1/users/%2&quot; ).arg( url, user ) );

      QVariantMap details;
      details[&quot;lastImportPath&quot;] = settings.value( &quot;lastImportPath&quot; ).toString();
      details[&quot;importPaths&quot;] = importedFolders.contains( QStringLiteral( &quot;%1 - %2&quot; ).arg( decodedUrl, decodedUser ) ) ? importedFolders[QStringLiteral( &quot;%1 - %2&quot; ).arg( decodedUrl, decodedUser )] : QVariantMap();
      usersDetails[decodedUser] = details;

      if ( lastUserImportTime &lt; settings.value( &quot;lastImportTime&quot; ).toDateTime() )
      {
        lastUserImportTime = settings.value( &quot;lastImportTime&quot; ).toDateTime();
        lastUser = decodedUser;
      }
      if ( lastUrlImportTime &lt; settings.value( &quot;lastImportTime&quot; ).toDateTime() )
      {
        lastUrlImportTime = settings.value( &quot;lastImportTime&quot; ).toDateTime();
        lastUrl = decodedUrl;
      }
    }

    QVariantMap details;
    details[&quot;users&quot;] = usersDetails;
    details[&quot;lastUser&quot;] = lastUser;
    urlsDetails[decodedUrl] = details;
  }

  history[&quot;urls&quot;] = urlsDetails;
  history[&quot;lastUrl&quot;] = lastUrl;

  return history;
}

void WebdavConnection::putLocalItems()
{
  if ( !mWebdavMkDirs.isEmpty() )
  {
    const QString dirPath = mWebdavMkDirs.first();

    QNetworkReply *reply = mWebdavConnection.mkdir( dirPath );

    connect( reply, &amp;QNetworkReply::finished, this, [this, reply, dirPath]() {
      mBytesProcessed += mCurrentBytesProcessed;
      mCurrentBytesProcessed = 0;
      emit progressChanged();
      if ( reply-&gt;error() != QNetworkReply::NoError )
      {
        mLastError = tr( &quot;Failed to upload file %1 due to network error (%2)&quot; ).arg( dirPath ).arg( reply-&gt;error() );
      }

      mWebdavMkDirs.removeFirst();
      putLocalItems();
    } );
  }
  else if ( !mLocalItems.isEmpty() )
  {
    const QString itemPath = mLocalItems.first().absoluteFilePath();
    const QString remoteItemPath = mProcessRemotePath + itemPath.mid( mProcessLocalPath.size() ).replace( QDir::separator(), &quot;/&quot; );

    QFile *file = new QFile( itemPath );
    file-&gt;open( QFile::ReadOnly );
    QNetworkReply *reply = mWebdavConnection.put( remoteItemPath, file );
    file-&gt;setParent( reply );

    connect( reply, &amp;QNetworkReply::uploadProgress, this, [this, reply]( qint64 bytesSent, qint64 bytesTotal ) {
      mCurrentBytesProcessed = bytesSent;
      emit progressChanged();
    } );

    connect( reply, &amp;QNetworkReply::finished, this, [this, reply, remoteItemPath]() {
      mBytesProcessed += mCurrentBytesProcessed;
      mCurrentBytesProcessed = 0;
      emit progressChanged();
      if ( reply-&gt;error() != QNetworkReply::NoError )
      {
        mLastError = tr( &quot;Failed to upload file %1 due to network error (%2)&quot; ).arg( remoteItemPath ).arg( reply-&gt;error() );
      }

      mWebdavLastModified &lt;&lt; remoteItemPath;

      mLocalItems.removeFirst();
      putLocalItems();
      reply-&gt;deleteLater();
    } );
  }
  else
  {
    if ( mIsUploadingPath )
    {
      if ( !mWebdavLastModified.isEmpty() )
      {
        mWebdavDirParser.listDirectory( &amp;mWebdavConnection, mProcessRemotePath, true );
      }
      else
      {
        mIsUploadingPath = false;
        emit isUploadingPathChanged();
      }
    }
  }
}

void WebdavConnection::importPath( const QString &amp;remotePath, const QString &amp;localPath, QString localFolder )
{
  if ( mUrl.isEmpty() || mUsername.isEmpty() || ( mPassword.isEmpty() &amp;&amp; mStoredPassword.isEmpty() ) )
    return;

  setupConnection();

  if ( localFolder.isEmpty() )
  {
    localFolder = QStringLiteral( &quot;%1 - %2&quot; ).arg( remotePath, mWebdavConnection.username() );
  }
  localFolder.replace( QRegularExpression( &quot;[\\\\\\/\\&lt;\\&gt;\\:\\|\\?\\*\\\&quot;]&quot; ), QString( &quot;_&quot; ) );

  QDir localDir( localPath );
  QString localFolderCheck = localFolder;
  int folderSuffix = 0;
  while ( localDir.exists( localFolderCheck ) )
  {
    localFolderCheck = QStringLiteral( &quot;%1 - %2&quot; ).arg( localFolder, QString::number( ++folderSuffix ) );
  }
  localFolder = localFolderCheck;

  mProcessRemotePath = remotePath;
  mProcessLocalPath = QDir::cleanPath( localPath + QDir::separator() + localFolder ) + QDir::separator();

  mWebdavItems.clear();
  mBytesProcessed = 0;
  mBytesTotal = 0;
  emit progressChanged();

  mIsImportingPath = true;
  emit isImportingPathChanged();

  mWebdavDirParser.listDirectory( &amp;mWebdavConnection, mProcessRemotePath, true );
}

void WebdavConnection::downloadPath( const QString &amp;localPath )
{
  QDir dir( localPath );
  bool webdavConfigurationExists = dir.exists( &quot;qfield_webdav_configuration.json&quot; );
  QStringList remoteChildrenPath;
  while ( !webdavConfigurationExists )
  {
    remoteChildrenPath.prepend( dir.dirName() );
    if ( !dir.cdUp() )
      break;

    webdavConfigurationExists = dir.exists( &quot;qfield_webdav_configuration.json&quot; );
  }

  if ( webdavConfigurationExists )
  {
    QFile webdavConfigurationFile( dir.absolutePath() + QDir::separator() + QStringLiteral( &quot;qfield_webdav_configuration.json&quot; ) );
    webdavConfigurationFile.open( QFile::ReadOnly );
    QJsonDocument jsonDocument = QJsonDocument::fromJson( webdavConfigurationFile.readAll() );
    if ( !jsonDocument.isEmpty() )
    {
      QVariantMap webdavConfiguration = jsonDocument.toVariant().toMap();
      setUrl( webdavConfiguration[&quot;url&quot;].toString() );
      setUsername( webdavConfiguration[&quot;username&quot;].toString() );
      setStorePassword( isPasswordStored() );

      mProcessRemotePath = webdavConfiguration[&quot;remote_path&quot;].toString();
      if ( !remoteChildrenPath.isEmpty() )
      {
        mProcessRemotePath = mProcessRemotePath + remoteChildrenPath.join( &quot;/&quot; ) + QStringLiteral( &quot;/&quot; );
      }
      mProcessLocalPath = QDir::cleanPath( localPath ) + QDir::separator();

      mWebdavItems.clear();
      mBytesProcessed = 0;
      mBytesTotal = 0;
      emit progressChanged();

      mIsDownloadingPath = true;
      emit isDownloadingPathChanged();
      const QUrl url( mUrl );
      emit confirmationRequested( url.host(), mUsername );
    }
  }
}

void WebdavConnection::uploadPaths( const QStringList &amp;localPaths )
{
  mLocalItems.clear();
  bool webdavConfigurationExists = false;
  QJsonDocument webdavJson;
  QVariantMap webdavConfiguration;

  for ( const QString &amp;localPath : localPaths )
  {
    QFileInfo fi( QDir::cleanPath( localPath ) );
    const QString fileLocalPath = fi.isFile() ? fi.absolutePath() : fi.absoluteFilePath();
    QDir dir( fileLocalPath );
    QStringList remoteChildrenPath;

    while ( !dir.exists( &quot;qfield_webdav_configuration.json&quot; ) )
    {
      remoteChildrenPath.prepend( dir.dirName() );
      if ( !dir.cdUp() )
        break;
    }

    if ( !webdavConfigurationExists )
    {
      webdavConfigurationExists = dir.exists( &quot;qfield_webdav_configuration.json&quot; );

      if ( webdavConfigurationExists )
      {
        const QString webdavConfigurationPath = dir.absolutePath() + QDir::separator() + QStringLiteral( &quot;qfield_webdav_configuration.json&quot; );
        QFile webdavConfigurationFile( webdavConfigurationPath );
        webdavConfigurationFile.open( QFile::ReadOnly );
        webdavJson = QJsonDocument::fromJson( webdavConfigurationFile.readAll() );

        if ( !webdavJson.isEmpty() )
        {
          webdavConfiguration = webdavJson.toVariant().toMap();
          setUrl( webdavConfiguration[&quot;url&quot;].toString() );
          setUsername( webdavConfiguration[&quot;username&quot;].toString() );
          setStorePassword( isPasswordStored() );
          mProcessLocalPath = fi.isFile() ? fi.absolutePath() : fi.absoluteFilePath();
          mProcessRemotePath = webdavConfiguration[&quot;remote_path&quot;].toString();

          if ( !remoteChildrenPath.isEmpty() )
          {
            mProcessRemotePath = mProcessRemotePath + remoteChildrenPath.join( &quot;/&quot; ) + QStringLiteral( &quot;/&quot; );
          }
        }
      }
    }
    else if ( !webdavJson.isEmpty() )
    {
      QString newRemotePath = webdavConfiguration[&quot;remote_path&quot;].toString();
      if ( !remoteChildrenPath.isEmpty() )
      {
        newRemotePath = newRemotePath + remoteChildrenPath.join( &quot;/&quot; ) + QStringLiteral( &quot;/&quot; );
      }
      mProcessRemotePath = getCommonPath( newRemotePath, mProcessRemotePath );
    }

    if ( !webdavJson.isEmpty() )
    {
      if ( fi.isDir() )
      {
        QDirIterator it( fileLocalPath, QDir::Files | QDir::NoDotAndDotDot, QDirIterator::Subdirectories );
        while ( it.hasNext() )
        {
          it.next();
          if ( it.fileName() != QStringLiteral( &quot;qfield_webdav_configuration.json&quot; ) )
          {
            mLocalItems &lt;&lt; it.fileInfo();
          }
        }
      }
      else
      {
        mLocalItems &lt;&lt; fi;
      }

      mProcessLocalPath = getCommonPath( fileLocalPath, mProcessLocalPath );
    }
  }

  mBytesProcessed = 0;
  mBytesTotal = 0;
  emit progressChanged();

  mIsUploadingPath = true;
  emit isUploadingPathChanged();
  const QUrl url( mUrl );
  emit confirmationRequested( url.host(), mUsername );
}


QString WebdavConnection::getCommonPath( const QString &amp;addressA, const QString &amp;addressB )
{
  const QStringList pathComponentsA = addressA.split( &quot;/&quot; );
  const QStringList pathComponentsB = addressB.split( &quot;/&quot; );
  const qsizetype minLength = std::min( pathComponentsA.size(), pathComponentsB.size() );

  QString commonPath = QStringLiteral( &quot;/&quot; );

  for ( qsizetype i = 0; i &lt; minLength; ++i )
  {
    if ( pathComponentsA[i] == pathComponentsB[i] )
    {
      if ( i &gt; 0 )
      {
        commonPath += pathComponentsA[i] + QStringLiteral( &quot;/&quot; );
      }
    }
    else
    {
      break;
    }
  }

  while ( !commonPath.isEmpty() &amp;&amp; commonPath.endsWith( &quot;/&quot; ) )
  {
    commonPath.chop( 1 );
  }

  commonPath += QStringLiteral( &quot;/&quot; );

  return commonPath;
}

void WebdavConnection::confirmRequest()
{
  if ( mIsDownloadingPath || mIsUploadingPath )
  {
    setupConnection();
    mWebdavDirParser.listDirectory( &amp;mWebdavConnection, mProcessRemotePath, true );
  }
}

void WebdavConnection::cancelRequest()
{
  if ( mIsDownloadingPath )
  {
    mIsDownloadingPath = false;
    emit isDownloadingPathChanged();
  }
  else if ( mIsUploadingPath )
  {
    mIsUploadingPath = false;
    emit isUploadingPathChanged();
  }
}

double WebdavConnection::progress() const
{
  if ( ( mIsImportingPath || mIsDownloadingPath || mIsUploadingPath ) &amp;&amp; mBytesTotal &gt; 0 )
  {
    return static_cast&lt;double&gt;( mBytesProcessed + mCurrentBytesProcessed ) / mBytesTotal;
  }

  return 0;
}

void WebdavConnection::processConnectionError( const QString &amp;error )
{
  mLastError = error;
  emit lastErrorChanged();
}

void WebdavConnection::processDirParserError( const QString &amp;error )
{
  mLastError = error;
  emit lastErrorChanged();
}

bool WebdavConnection::hasWebdavConfiguration( const QString &amp;path )
{
  const QFileInfo fileInfo( path );
  QDir dir( fileInfo.isFile() ? fileInfo.absolutePath() : fileInfo.absoluteFilePath() );
  bool webdavConfigurationExists = dir.exists( &quot;qfield_webdav_configuration.json&quot; );
  while ( !webdavConfigurationExists &amp;&amp; dir.cdUp() )
  {
    webdavConfigurationExists = dir.exists( &quot;qfield_webdav_configuration.json&quot; );
  }
  return webdavConfigurationExists;
}
</code></pre>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
    <div class="md-copyright__highlight">
      Copyright &copy; 2023 <a href="https://OPENGIS.ch">OPENGIS.ch</a> -  <a href="https://creativecommons.org/licenses/by-sa/4.0/" target="_blank">CC-BY-SA 4.0</a>
    </div>
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      
      <script id="__config" type="application/json">{"annotate": null, "base": "../..", "features": [], "search": "../../assets/javascripts/workers/search.2c215733.min.js", "tags": null, "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": null}</script>
    
    
      <script src="../../assets/javascripts/bundle.79ae519e.min.js"></script>
      
    
  </body>
</html>